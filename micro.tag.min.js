(() => {
  'use strict';

  var e = {
    9618: (e, t) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize broadcastInfo and unBroadcastAllInfo as undefined
      t.broadcastInfo = undefined;
      t.unBroadcastAllInfo = undefined;

      // Define a constant for the default dataset field and an array to store info objects
      const DEFAULT_DATASET_FIELD = 'zfgformats';
      const infoArray = [];

      // Helper function to remove an element from arrays
      function removeFromArrays(element) {
        const datasetField = window.document.documentElement.dataset.fp || DEFAULT_DATASET_FIELD;
        [window[datasetField] || [], infoArray].forEach(array => {
          const index = array.indexOf(element);
          if (index > -1) {
            array.splice(index, 1);
          }
        });
      }

      // Define the broadcastInfo function
      t.broadcastInfo = function(format, version, zoneId, scriptElement, extraData) {
        let domain;

        try {
          if (scriptElement instanceof HTMLScriptElement) {
            domain = scriptElement.src.split('/')[2];
          }
        } catch (error) {
          // Handle potential errors
        }

        const datasetField = window.document.documentElement.dataset.fp || DEFAULT_DATASET_FIELD;

        if (window[datasetField]) {
          window[datasetField].forEach(entry => {
            if (entry.zoneId === zoneId && entry.sourceZoneId) {
              zoneId = entry.sourceZoneId;
              domain = entry.domain;
            }
          });
        } else {
          window[datasetField] = [];
        }

        const info = {
          format: format,
          version: version,
          zoneId: zoneId,
          domain: domain,
        };

        if (extraData) {
          info.extra = { sd: extraData };
        }

        infoArray.push(info);
        window[datasetField].push(info);
      };

      // Define the unBroadcastAllInfo function
      t.unBroadcastAllInfo = function() {
        infoArray.forEach(removeFromArrays);
      };
    },
    3463: (e, t) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the isGoogleLighthouse function as undefined
      t.isGoogleLighthouse = undefined;

      // Define the isGoogleLighthouse function
      t.isGoogleLighthouse = () => {
        // Get the user agent string from the navigator
        const userAgent = navigator.userAgent;

        // Create a regular expression to test for Chrome-Lighthouse in the user agent string
        const lighthouseRegex = new RegExp('Chrome-Lighthouse', '');

        // Test the user agent string against the regular expression
        return lighthouseRegex.test(userAgent);
      };
    },
    3578: (e, t, r) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the concatClientHints function as undefined
      t.concatClientHints = undefined;

      // Import the getHighEntropyValues function from the provided module
      const { getHighEntropyValues } = r(6322);

      // Define a constant object to use in case of an error
      const ERROR_OBJECT = { error: 'ch_too_long' };

      // Define the concatClientHints function
      t.concatClientHints = async function(urls) {
        // Get high entropy values using the imported function
        const highEntropyValues = await getHighEntropyValues();

        // If high entropy values are not available, return the original URLs
        if (!highEntropyValues) return urls;

        // Encode the high entropy values as a base64 string
        const encodedValues = btoa(JSON.stringify(highEntropyValues));
        const encodedLength = encodedValues.length;

        // Map over each URL and append the client hints if the length allows
        return urls.map(url => {
          const urlLength = url.length;
          if (urlLength < 2048) {
            const newUrl = urlLength + encodedLength < 2048 ? `${url}&ch=${encodedValues}` : `${url}&ch=${btoa(JSON.stringify(ERROR_OBJECT))}`;
            return newUrl;
          }
          return url;
        });
      };
    },
    3882: (e, t) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the getOptionsFromUrl function as undefined
      t.getOptionsFromUrl = undefined;

      // Define the getOptionsFromUrl function
      t.getOptionsFromUrl = url => {
        // Parse the query parameters from the URL
        const queryParams = url.search.slice(1).split('&').reduce((acc, param) => {
          const [key, value] = param.split('=');
          acc[key] = value;
          return acc;
        }, {});

        // Define the options mapping
        const optionsMapping = [
          ['cdn', 'cdn', Boolean], ['domain', 'domain', String], ['var', 'var', String], ['ymid', 'ymid', String], ['var_3', 'var_3', String], ['var_4', 'var_4', String], ['m', 'forcePopup', val => 'http' === val],
          ['m', 'forceStandalone', val => 'https' === val], ['dnd', 'notificationsDelayHttps', Number], ['dsws', 'disableSwSanity', Boolean], ['mpcd', 'afterCloseDelay', Number], ['zoneId', 'zoneId', Number],
          ['p', 'zoneId', Number], ['z', 'zoneId', Number], ['rtmu', 'useRtMarkUser', val => 'true' === val], ['sw', 'swName', decodeURIComponent], ['gt', 'gidratorTimeout', Number],
          ['pub', 'pub', val => Number(val) || 0], ['t', 't', String], ['autoInstall', 'autoInstall', val => !(val && 'false' === val)], ['exp', 'experiment', String], ['dsig', 'dsig', String], ['dc', 'dc', Boolean],
          ['dcv', 'dcv', Number], ['ab2', 'ab2', String], ['ab2_ttl', 'ab2_ttl', String], ['uhd', 'uhd', String], ['oaid', 'oaid', String], ['nouns', 'nouns', Number], ['noel', 'noel', Number], ['rpo', 'rpo', Number],
          ['wua', 'wua', Number]];

        // Reduce the options mapping to an options object
        const options = optionsMapping.reduce((acc, [queryKey, optionKey, parser]) => {
          if (queryParams[queryKey] !== undefined) {
            acc[optionKey] = parser(queryParams[queryKey]);
          }
          return acc;
        }, {});

        return options;
      };
    },
    158: (e, t, r) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the isMyCurrentSubscription and isMySubscription functions as undefined
      t.isMyCurrentSubscription = undefined;
      t.isMySubscription = undefined;

      // Import necessary modules
      const { trackDb } = r(6344);
      const { subscrDb } = r(9199);
      const { sendError } = r(9178);

      // Define the isMySubscription function
      async function isMySubscription(subscription) {
        if (!subscription) return false;

        // Retrieve the registration context from the database
        const registrationContext = await trackDb().get('registration-context');
        let subscriptionJSON;

        // Attempt to convert the subscription to a JSON object
        try {
          subscriptionJSON = subscription.toJSON();
        } catch (error) {
          // Handle potential errors
        }

        // Check if the auth key matches the one in the registration context
        if (registrationContext && registrationContext.auth === (subscriptionJSON?.keys?.auth)) {
          return true;
        }

        // Check if the subscription exists in the subscription database
        try {
          const subscriptionDbEntry = await subscrDb().get(subscription);
          return Boolean(subscriptionDbEntry);
        } catch (error) {
          sendError('check_sub_error:', error, {});
          return false;
        }
      }

      // Export the isMySubscription function
      t.isMySubscription = isMySubscription;

      // Define the isMyCurrentSubscription function
      t.isMyCurrentSubscription = async function(scope = '', registration) {
        const serviceWorker = navigator.serviceWorker;

        if (serviceWorker) {
          const swRegistration = registration || (await serviceWorker.getRegistration(scope));

          if (swRegistration) {
            try {
              const pushSubscription = await swRegistration.pushManager.getSubscription();
              return !!pushSubscription && (await isMySubscription(pushSubscription));
            } catch (error) {
              sendError('cant_get_subscription:', error, {});
              return false;
            }
          }
        }

        return false;
      };
    },
    3833: (e, t, r) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });
      t.appLock = t.getLock = t.SW_BROWSER_ERROR_REG = undefined;

      // Import the required module
      const openDbModule = r(3799);
      const lockFailedError = new Error('Lock failed');

      // Function to create a lock
      function createLock(lockDuration = 900000) {
        const currentTimeSlot = Math.floor(Date.now() / lockDuration);
        const key = 'key';
        const dbConfig = {
          name: 'blockDb',
          version: 1,
          trackStore: 'blockStore',
          autoIncrement: true,
          keyPath: key,
        };

        // Function to open the database
        const openDb = async () => await openDbModule.openDb(dbConfig, (db) => {
          db.createIndex(key, key, { unique: true });
        });

        // Function to request a lock
        async function requestLock() {
          try {
            const db = await openDb();
            await db.add({ i: currentTimeSlot });
            return true;
          } catch (error) {
            console.error(error);
            if (!t.SW_BROWSER_ERROR_REG.test(error.message) && !(typeof IDBRequest === 'function' && error.target instanceof IDBRequest)) {
              console.warn(error);
            }
            return false;
          }
        }

        // Function to release a lock
        async function releaseLock() {
          try {
            const db = await openDb();
            await db.deleteByIndex(key, currentTimeSlot);
          } catch (error) {
            console.warn(error);
          }
        }

        return {
          // Function to check if the lock is active
          isLocked: async function() {
            try {
              const db = await openDb();
              return Boolean(await db.get(currentTimeSlot));
            } catch (error) {
              return false;
            }
          },
          request: requestLock,
          release: releaseLock,
          runReleaseOnFail: async function(action) {
            if (!await requestLock()) throw lockFailedError;
            const result = action();
            result.catch(releaseLock);
            return result;
          },
          LOCK_FAILED: lockFailedError,
        };
      }

      // Define the regular expression for browser error messages
      t.SW_BROWSER_ERROR_REG = new RegExp('The user denied permission to use Service Worker', 'gi');
      // Export the createLock function
      t.getLock = createLock;
      // Create and export the app lock
      t.appLock = createLock();
    },
    6322: (e, t) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the getHighEntropyValues function as undefined
      t.getHighEntropyValues = undefined;

      // Define the getHighEntropyValues function
      t.getHighEntropyValues = async function() {
        // Check if navigator is available
        if (!navigator) {
          return Promise.resolve(null);
        }

        // Check if userAgentData is available
        if (!navigator.userAgentData) {
          return Promise.resolve(null);
        }

        // Check if getHighEntropyValues is available and is a function
        if (!navigator.userAgentData.getHighEntropyValues || typeof navigator.userAgentData.getHighEntropyValues !== 'function') {
          return Promise.resolve(null);
        }

        // Try to get high entropy values
        try {
          return await navigator.userAgentData.getHighEntropyValues([
            'model', 'platformVersion', 'architecture', 'bitness', 'formFactor', 'fullVersionList', 'wow64']);
        } catch (error) {
          // Return null if an error occurs
          return Promise.resolve(null);
        }
      };
    },
    4101: (e, t) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Export the default function
      t.default = function() {
        return {
          // Method to get a cookie by name
          get: (name) => {
            const match = document.cookie.match(new RegExp(`(^|; )${name}=([^;]*)`));
            return { val: (match || [])[2] };
          },

          // Method to set a cookie
          set: function(name, value, days = 0) {
            const currentDate = new Date();
            const expirationDate = days > 0 ? new Date(currentDate.setDate(currentDate.getDate() + days)) : 0;
            document.cookie = `${name}=${value}; expires=${String(expirationDate)};`;
          },
        };
      };
    },
    3010: (e, t) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the delay function as undefined
      t.delay = undefined;

      // Define the delay function
      t.delay = function(milliseconds) {
        // Return a Promise that resolves after the specified milliseconds
        return new Promise(resolve => setTimeout(resolve, milliseconds));
      };
    },
    8869: (e, t) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the errorHelper function as undefined
      t.errorHelper = undefined;

      // Define the errorHelper function
      t.errorHelper = (error, context = {}) => {
        // Return a default error object if the error is null or undefined
        if (error == null) {
          return {
            message: 'error is undefined or null',
            stack: 'unknown',
            level: 'unknown',
          };
        }

        // Convert the context object to a JSON string
        const contextString = context != null ? JSON.stringify(context) : 'no-ctx';

        // Return a detailed error object
        return {
          message: `error-obj: ${error.toString ? error.toString() : JSON.stringify(error)}, error-msg: ${error.message ? error.message : 'no-message'}, error-name: ${error.name ?
              error.name :
              'no-name'}, error-code: ${error.code ? error.code : 'no-code'}, error-ctx: ${contextString}`,
          stack: error.stack ? error.stack : 'unknown',
          level: error.error_level ? error.error_level : 'unknown',
        };
      };
    },
    8183: (e, t, r) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Import necessary modules
      const { sendError } = r(9178);
      const { swPingDomain } = r(8066);
      const { sendCustom } = r(8594);

      // Define the eventLogger class
      class EventLogger {
        constructor() {
          this.domain = '';
          this.options = {};
          this.oaid = '';
        }

        // Set the context for the logger
        setContext(domain, options) {
          // Ensure the domain starts with 'https://' or 'http://'
          if (!domain.startsWith('https://') && !domain.startsWith('http://')) {
            domain = `https://${domain}`;
          }
          this.domain = domain;
          this.options = options;
        }

        // Update the existing context options
        updateContext(newOptions) {
          this.options = { ...this.options, ...newOptions };
        }

        // Set the domain for the logger
        setDomain(domain) {
          this.domain = domain;
        }

        // Set the OAID (Optional Application Identifier)
        setOAID(oaid) {
          this.oaid = oaid;
        }

        // Get the OAID
        getOAID() {
          return this.oaid;
        }

        // Set the user ID in the options
        setUserId(userId) {
          if (this.options) {
            this.options.oaid = userId;
          }
        }

        // Send an event with the provided data
        send(eventData, errorCallback) {
          // If the domain is not set, log the event data if in debug mode and resolve the promise
          if (!this.domain) {
            if (location.href.indexOf('debug') > 0) {
              console.log(eventData, errorCallback);
            }
            return Promise.resolve();
          }

          // Merge the options with the event data
          const data = { ...this.options, ...eventData };
          // Determine the domain to use (this.domain or swPingDomain)
          const domainToUse = this.domain || swPingDomain;

          // Send the custom event
          return sendCustom(domainToUse, data, this.options?.useBeaconForEvent, this.oaid)
          .catch(error => {
            console.warn('event-logger-error: ', error);
            // If an error callback is provided, send the error
            if (errorCallback) {
              return sendError('event-logger-error:', error, data, errorCallback);
            }
          })
          .finally(() => {
            // Resolve the promise in any case
            return Promise.resolve();
          });
        }
      }

      // Initialize the eventLogger as an instance of the EventLogger class
      t.eventLogger = new EventLogger();
    },
    6289: (e, t) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the TIMEOUT_ERROR and failByTimeout as undefined
      t.TIMEOUT_ERROR = undefined;
      t.failByTimeout = undefined;

      // Define the TIMEOUT_ERROR
      t.TIMEOUT_ERROR = new Error('TIMEOUT_ERROR');

      // Define the failByTimeout function
      t.failByTimeout = timeout => {
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            reject(t.TIMEOUT_ERROR);
          }, timeout);
        });
      };
    },
    9321: (e, t) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the browsersDetection function as undefined
      t.browsersDetection = undefined;

      // Define the browsersDetection function
      t.browsersDetection = function(userAgent) {
        // Extract the Chrome version number from the user agent string
        const chromeVersion = Number(userAgent.replace(/^(.*)((Chrome|CriOS)\/([0-9]{2,3}))(.*)$/, '$4'));

        // Test for iPhone, iPad, or iPod in the user agent string
        const isIOS = /iPhone|iPad|iPod/.test(userAgent);

        // Test for Yandex Browser in the user agent string
        const isYandexBrowser = /YaBrowser/.test(userAgent);

        // Determine if the browser is Chrome and not Yandex Browser
        const isChrome = Boolean(chromeVersion && !isYandexBrowser);

        // Return an object with detection results
        return {
          isFF: /Firefox/.test(userAgent),
          isSafariDesktop: /Safari/.test(userAgent) && !isChrome && !isIOS,
        };
      };
    },
    6837: function(e, t, r) {
      // Helper function to import a module and handle __esModule
      var n = this && this.__importDefault || function(e) {
        return e && e.__esModule ? e : { 'default': e };
      };

      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the gidCookie object as undefined
      t.gidCookie = undefined;

      // Import the cookie library
      const o = n(r(4101));

      // Define the gidCookie object with various methods
      t.gidCookie = {
        // Check if the user is skipped by Gidrator for the day
        isSkippedByGidForDay: () => undefined !== o.default().get('_PN_SBSCRBR_SKIP_BY_GIDRATOR').val,

        // Skip the user by Gidrator for the day
        skipByGidForDay: () => o.default().set('_PN_SBSCRBR_SKIP_BY_GIDRATOR', Date.now(), 1),

        // Check if the iframe is skipped for the year
        isSkippedIframeForYear: () => undefined !== o.default().get('_PN_SBSCRBR').val,

        // Skip the iframe for the year
        skipIframeForYear: () => o.default().set('_PN_SBSCRBR', Date.now(), 365),

        // Skip the fallback for the day
        skipFallBackForDay: () => o.default().set('_PN_SBSCRBR_FALLBACK_DENIED', Date.now(), 1),

        // Check if the fallback is skipped for the day
        isSkippedFallBackForDay: () => undefined !== o.default().get('_PN_SBSCRBR_FALLBACK_DENIED').val,
      };
    },
    9300: (e, t) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the inject function as undefined
      t.inject = undefined;

      // Define the inject function
      t.inject = function(scripts) {
        // Use setTimeout to defer the execution to the next event loop
        setTimeout(() => {
          // Iterate over each script URL in the provided array
          scripts.forEach(scriptUrl => {
            // Use setTimeout to defer the script injection for each URL
            setTimeout(() => {
              // Create a new script element
              const scriptElement = document.createElement('script');
              // Set the src attribute to the script URL
              scriptElement.src = scriptUrl;
              // Append the script element to the document head if it exists
              if (document.head) {
                document.head.append(scriptElement);
              }
            }, 0);
          });
        }, 0);
      };
    },
    3544: (e, t, r) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the buildInstallEventParams function as undefined
      t.buildInstallEventParams = undefined;

      // Import the necessary module
      const { swVersion } = r(8066);

      // Define a helper function to get the domain from the current URL
      const getDomain = () => {
        try {
          return self.location.href.split('/')[2];
        } catch (error) {
          return '';
        }
      };

      // Define the buildInstallEventParams function
      t.buildInstallEventParams = (params, traceId, installerType, useBeaconForEvent = true) => {
        return {
          zone_id: params.zoneId || params.z,
          sw_version: swVersion,
          trace_id: traceId,
          location: self.location && self.location.href,
          domain: getDomain(),
          pub: params.pub || 0,
          request_var: params.var,
          ymid: params.ymid,
          var_3: params.var_3,
          installer_type: installerType,
          useBeaconForEvent: useBeaconForEvent,
        };
      };
    },
    351: (e, t) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the isPushSupported function as undefined
      t.isPushSupported = undefined;

      // Define the isPushSupported function
      t.isPushSupported = () => {
        // Check if the necessary APIs for push notifications are supported
        return 'serviceWorker' in navigator && 'Notification' in window && 'PushManager' in window && 'showNotification' in ServiceWorkerRegistration.prototype;
      };
    },
    3799: (e, t, r) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the openDb function as undefined
      t.openDb = undefined;

      // Import necessary modules
      const { sendError } = r(9178);

      // Define the openDb function
      t.openDb = async function(dbConfig, upgradeCallback) {
        return new Promise((resolve, reject) => {
          // Open the IndexedDB database
          const request = self.indexedDB.open(dbConfig.name, dbConfig.version);

          // Handle the onupgradeneeded event
          request.onupgradeneeded = event => {
            const db = event.target.result;
            const version = Number(dbConfig.version);

            // Handle database upgrade based on version
            if (version === 1) {
              const objectStore = db.createObjectStore(dbConfig.trackStore, {
                autoIncrement: dbConfig.autoIncrement,
                keyPath: dbConfig.keyPath,
              });

              // Call the upgrade callback if provided
              if (upgradeCallback) {
                upgradeCallback(objectStore, version);
              }
            }
          };

          // Handle the onsuccess event
          request.onsuccess = () => resolve(request.result);

          // Handle the onerror event
          request.onerror = event => {
            const error = event.target.error;
            sendError(`open_db_error_${dbConfig.name}:`, error, {});
            reject(error);
          };
        }).then(db => {
          // Helper function to perform database operations
          function performOperation(operation, mode = 'readwrite') {
            return new Promise((resolve, reject) => {
              try {
                const transaction = db.transaction(dbConfig.trackStore, mode);
                const objectStore = transaction.objectStore(dbConfig.trackStore);
                const request = operation(objectStore);

                request.onsuccess = event => {
                  resolve(event.target.result);
                };

                request.onerror = reject;
              } catch (error) {
                sendError(`open_db_transaction_${dbConfig.trackStore}:`, error, {});
                reject(error);
              }
            });
          }

          // Return an object with methods to interact with the database
          return {
            increment: async key => {
              return new Promise(resolve => {
                const transaction = db.transaction(dbConfig.trackStore, 'readwrite');
                const objectStore = transaction.objectStore(dbConfig.trackStore);
                const getRequest = objectStore.get(key);

                getRequest.onsuccess = () => {
                  const value = getRequest.result;
                  const newValue = value == null ? 1 : Number(value) + 1;
                  const putRequest = objectStore.put(newValue, key);

                  putRequest.onsuccess = () => {
                    resolve({
                      key: key,
                      indexedDBValue: value,
                    });
                  };
                };
              });
            },
            add: async value => await performOperation(store => store.add(value)),
            put: async value => await performOperation(store => store.put(value)),
            get: async key => await performOperation(store => store.get(key), 'readonly'),
            set: async (key, value) => await performOperation(store => store.put(value, key)),
            getAll: async () => await performOperation(store => store.getAll()),
            getAllKeys: async () => await performOperation(store => store.getAllKeys()),
            clear: async () => await performOperation(store => store.clear()),
            delete: async key => await performOperation(store => store.delete(key)),
            deleteByIndex: async function(indexName, key) {
              const indexKey = await performOperation(store => store.index(indexName).getKey(key));
              return await performOperation(store => store.delete(indexKey));
            },
          };
        });
      };
    },
    6301: (e, t, r) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the runPerformanceObserver function as undefined
      t.runPerformanceObserver = undefined;

      // Import necessary modules
      const { sendError } = r(9178);
      const { eventLogger } = r(8183);
      const { swFallbackErrorDomain } = r(8066);

      // Define the regex patterns to exclude certain resources
      const excludePatterns = [
        new RegExp('https?:\\/\\/[\\w.-]+\\/custom\\b', 'i')];

      // Define the runPerformanceObserver function
      t.runPerformanceObserver = function(params) {
        const {
          context,
          traceId,
        } = params;

        try {
          // Create a new PerformanceObserver instance
          new PerformanceObserver(entryList => {
            // Get all 'resource' entries
            const entries = entryList.getEntriesByType('resource');

            // Process each resource entry
            for (const entry of entries) {
              // Check if the entry matches any of the exclude patterns
              if (excludePatterns.some(pattern => pattern.test(entry.name))) {
                continue;
              }

              // Create the performance data object
              const performanceData = {
                name: entry.name,
                connection_time: entry.connectEnd - entry.connectStart,
                duration: Number(entry.duration.toFixed(2)),
                server_wait_time: entry.responseStart - entry.requestStart,
              };

              // Add optional fields if available
              if (entry.transferSize) {
                performanceData.transfer_size = entry.transferSize;
              }
              if (entry.responseStatus) {
                performanceData.response_status = entry.responseStatus;
              }
              if (entry.secureConnectionStart > 0) {
                performanceData.ssl_time = entry.connectEnd - entry.secureConnectionStart;
              }

              // Send the performance data
              eventLogger.send({ event_type: 'performance', ...performanceData }, swFallbackErrorDomain);
            }
          }).observe({ entryTypes: ['resource'] });

        } catch (error) {
          // Create a new error object with additional context information
          const detailedError = new Error();
          detailedError.error_level = context;
          detailedError.message = `${error.message}, context: ${context}`;

          // Send the error information
          sendError('performance_observer:', detailedError, {
            trace_id: traceId,
            installer_type: context,
          });
        }
      };
    },
    7353: (e, t, r) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the promiseOrFailByTimeout function as undefined
      t.promiseOrFailByTimeout = undefined;

      // Import necessary modules
      const { failByTimeout } = r(6289);

      // Define the promiseOrFailByTimeout function
      t.promiseOrFailByTimeout = (promise, timeout) => {
        // Use Promise.race to race the provided promise against the timeout promise
        return Promise.race([promise, failByTimeout(timeout)]);
      };
    },
    9199: (e, t, r) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the subscrDb function as undefined
      t.subscrDb = undefined;

      // Import necessary modules
      const { openDb } = r(3799);
      const { sendError } = r(9178);

      // Define the subscrDb function
      t.subscrDb = function(config = {
        name: 'subscriptionDb',
        version: 1,
        trackStore: 'subscriptionStore',
        keyPath: 'endpoint',
      }) {
        return {
          // Method to get a subscription from the database
          get: async key => {
            try {
              const db = await openDb(config);
              return await db.get(String(key.toJSON().endpoint));
            } catch (error) {
              // Set error level and send error report
              error.error_level = 'db';
              sendError('subscrDb_get:', error, {});
              return null;
            }
          }, // Method to set a subscription in the database
          set: async subscription => {
            try {
              const db = await openDb(config);
              return await db.put(subscription);
            } catch (error) {
              // Set error level and send error report
              error.error_level = 'db';
              sendError('subscrDb_set:', error, subscription || {});
            }
          },
        };
      };
    },
    6344: (e, t, r) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the trackDb function as undefined
      t.trackDb = undefined;

      // Import necessary modules
      const { openDb } = r(3799);
      const { swDatabase } = r(8066);

      // Define the trackDb function
      t.trackDb = function(databaseConfig = swDatabase) {
        return {
          // Method to get a value from the database
          get: async key => {
            try {
              const db = await openDb(databaseConfig);
              return await db.get(key);
            } catch (error) {
              // Return null if there is an error
              return null;
            }
          }, // Method to set a value in the database
          set: async (key, value) => {
            try {
              const db = await openDb(databaseConfig);
              return await db.set(key, value);
            } catch (error) {
              // Return null if there is an error
              return null;
            }
          }, // Method to delete a value from the database
          delete: async key => {
            try {
              const db = await openDb(databaseConfig);
              return await db.delete(key);
            } catch (error) {
              // Return false if there is an error
              return false;
            }
          },
        };
      };
    },
    9120: (e, t) => {
      // Function to generate a random character for the UUID
      function r(e) {
        const t = 16 * Math.random() | 0;
        return ('x' === e ? t : (3 & t) | 8).toString(16);
      }

      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the uuid4 function as undefined
      t.uuid4 = undefined;

      // Define the uuid4 function
      t.uuid4 = function() {
        // Generate a UUID v4 string by replacing 'x' and 'y' characters with random values
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, r);
      };
    },
    8366: (e, t) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the waitUserActivity function as undefined
      t.waitUserActivity = undefined;

      // Define the waitUserActivity function
      t.waitUserActivity = async function() {
        // List of events to listen for user activity
        const events = [
          'click', 'input', 'keypress', 'keyup', 'keydown'];

        // Return a promise that resolves when any of the events are triggered
        return new Promise(resolve => {
          // Event handler function
          const onUserActivity = () => {
            // Resolve the promise
            resolve();

            // Remove event listeners after the first event is triggered
            events.forEach(event => {
              self.removeEventListener(event, onUserActivity, true);
            });
          };

          // Add event listeners for each event in the list
          events.forEach(event => {
            self.addEventListener(event, onUserActivity, true);
          });
        });
      };
    },
    9814: (e, t, r) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the askGidrator function as undefined
      t.askGidrator = undefined;

      // Import necessary modules
      const { trackDb } = r(6344);
      const { promiseOrFailByTimeout } = r(7353);
      const { TIMEOUT_ERROR } = r(6289);
      const { gid } = r(5323);
      const { fetchService } = r(4532);
      const { sendError } = r(9178);

      const DEFAULT_TIMEOUT = 2000;

      // Define a simple cache using async get and set methods
      const cache = {
        get: async function() {
          try {
            return await trackDb().get('askGidrator');
          } catch (e) {
            // Handle any errors (optional)
          }
        },
        set: async function(data) {
          try {
            await trackDb().set('askGidrator', data);
          } catch (e) {
            // Handle any errors (optional)
          }
        },
      };

      let gidratorPromise = null;

      // Define the askGidrator function
      t.askGidrator = async (params, fetchFunc = fetchService) => {
        const {
          gidratorDomain,
          pusherDomainOAID,
          checkDuplicate,
          pub,
          zoneId,
          timeout = DEFAULT_TIMEOUT,
          var_id,
          ymid,
          var_3,
          context,
        } = params;

        // If checkDuplicate is false, try to retrieve cached data
        if (!checkDuplicate) {
          const cachedData = await cache.get();
          if (cachedData) {
            return {
              ...cachedData,
              skipSubscribe: false,
            };
          }
        }

        try {
          // Construct the request payload
          const payload = {
            userId: pusherDomainOAID || '',
            checkDuplicate,
            pub,
            zoneId,
            ymid,
            var: var_id,
            var_3,
          };

          // Use existing gidratorPromise or create a new one
          gidratorPromise = gidratorPromise || gid(gidratorDomain, payload, fetchFunc);

          // Await the gidrator response with a timeout
          const response = await promiseOrFailByTimeout(gidratorPromise, timeout);

          // Construct the result object
          const result = {
            gidratorOAID: response.gid,
            skipInstall: response.skipSubscribe,
            ok: true,
          };

          // Cache the result
          await cache.set(result);
          return result;

        } catch (error) {
          // Handle errors
          error.message = `${error.message}, context: ${context}, timeout: ${timeout}`;

          if (error === TIMEOUT_ERROR) {
            sendError('ask_gidrator_error_timeout:', error, {});
          } else {
            sendError('ask_gidrator_error:', error, {});
          }

          // Reset the gidratorPromise and return a fallback result
          gidratorPromise = null;
          return {
            gidratorOAID: String(pusherDomainOAID),
            skipInstall: false,
            ok: false,
          };
        }
      };
    },
    8255: (e, t) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the sendBeacon function as undefined
      t.sendBeacon = undefined;

      // Define the sendBeacon function
      t.sendBeacon = function(url, data) {
        // Check if navigator.sendBeacon is available
        if (navigator.sendBeacon) {
          try {
            // Send the beacon with the given URL and stringified data
            navigator.sendBeacon(url, JSON.stringify(data));
          } catch (error) {
            // Log any errors that occur
            console.error(error);
          }
        }
      };
    },
    4532: (e, t) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the fetchService function as undefined
      t.fetchService = undefined;

      // Define the fetchService function
      t.fetchService = async function(url, method, data, oaid) {
        // Add the timeOrigin property to the data object if the method is POST
        if (method === 'POST' && data && typeof data === 'object') {
          try {
            data.timeOrigin = performance.now();
          } catch (e) {
          }
        }

        // Stringify the data object for the request body
        const requestBody = JSON.stringify(data);

        // Set up the headers for the request
        const headers = method === 'POST' ? { 'Content-Type': 'application/json' } : {};
        if (oaid) {
          headers['X-Oaid'] = oaid;
        }

        // Define the fetch options
        const fetchOptions = {
          body: requestBody,
          method: method,
          credentials: 'include',
          headers: headers,
        };

        // Make the fetch request
        const response = await fetch(url, fetchOptions);

        // Try to parse the response as JSON
        try {
          return response.json();
        } catch (error) {
          // Throw a new error with detailed information if JSON parsing fails
          throw new Error(`${method}: ${url}; body: ${String(requestBody)}; http-status: ${response.status}; typedErrorMessage: ${error ? error.message : undefined}; stack: ${String(error.stack)}`);
        }
      };
    },
    5323: (e, t) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the gid function as undefined
      t.gid = undefined;

      // Define the gid function
      t.gid = async function(baseUrl, params, fetchFunction) {
        // Helper function to construct the URL with query parameters
        const constructUrl = (params, baseUrl) => {
          const queryParams = {
            pub: params.pub,
            userId: String(params.userId || ''),
            zoneId: params.zoneId,
            checkDuplicate: Boolean(params.checkDuplicate),
            ymid: params.ymid || '',
            var: params.var || '',
            source: 'pusher',
          };

          const queryString = Object.keys(queryParams)
                                    .map(key => `${key}=${queryParams[key]}`)
                                    .join('&');

          return `${baseUrl}/gid.js?${queryString}`;
        };

        // Construct the full URL
        const fullUrl = constructUrl(params, baseUrl);

        // Use the provided fetch function to make a GET request to the constructed URL
        return await fetchFunction(fullUrl, 'GET');
      };
    },
    8594: (e, t, r) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the sendCustom function as undefined
      t.sendCustom = undefined;

      // Import necessary modules
      const { sendBeacon } = r(8255);
      const { fetchService } = r(4532);

      // Define the sendCustom function
      t.sendCustom = async function(url, eventData, useBeacon, userKey) {
        // Construct the custom event URL
        const eventUrl = eventData.experiment ? `${url}/custom?${eventData.experiment}&trace_id=${eventData.trace_id}&event_type=${eventData.event_type}` : `${url}/custom`;

        // Check if beacon should be used and if navigator.sendBeacon is available
        if (useBeacon && navigator && typeof navigator.sendBeacon === 'function') {
          // Use sendBeacon to send the event data
          sendBeacon(eventUrl, eventData);
          return Promise.resolve(undefined);
        } else {
          // Use fetchService to send the event data
          return await fetchService(eventUrl, 'POST', eventData, userKey);
        }
      };
    },
    3737: (e, t, r) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the sendEvent function as undefined
      t.sendEvent = undefined;

      // Import the fetchService from the module
      const { fetchService } = r(4532);

      // Define the sendEvent function
      t.sendEvent = async function(url, data, userKey, fetchFunction = fetchService) {
        // Use the provided fetchFunction to send a POST request to the given URL
        // The URL is constructed by appending '/event' to the base URL
        // The data and userKey are sent in the request
        return await fetchFunction(`${url}/event`, 'POST', data, userKey);
      };
    },
    9178: (e, t, r) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the sendError function as undefined
      t.sendError = undefined;

      // Import necessary modules
      const { errorHelper } = r(8869);
      const {
        swVersion,
        swFallbackErrorDomain,
      } = r(8066);
      const { sendEvent } = r(3737);

      // Helper function to send error details
      async function sendErrorDetails(domain, message, error, context, fallback) {
        const errorDetails = errorHelper(error, context);
        const currentLocation = location && location.href ? String(location.href) : 'unknown';
        let userKey = {};

        if (typeof context === 'object') {
          if (typeof context.user_key === 'object') {
            userKey = context.user_key;
          }
          if (typeof context.registrationUser === 'object') {
            userKey = context.registrationUser;
          }
        }

        const traceId = typeof context === 'object' && typeof context.trace_id === 'string' ? context.trace_id : '';
        const failedDomain = typeof fallback === 'string' ? fallback : undefined;

        const eventData = {
          code: 'error_json',
          sw_version: String(swVersion),
          user_key: userKey,
          error_level: errorDetails.level,
          error_message: `${message}, message: ${errorDetails.message}, fallback: ${String(fallback)}`,
          error_stack: String(errorDetails.stack),
          error_location: currentLocation,
          trace_id: String(traceId),
          installer_type: context.installer_type,
          failed_domain: failedDomain,
        };

        const trueUserKey = userKey ? userKey.true_user : undefined;

        await sendEvent(domain, eventData, trueUserKey);
        return true;
      }

      // Main function to send error
      t.sendError = async function(message, error, context, fallbackDomain = swFallbackErrorDomain) {
        try {
          return await sendErrorDetails(String(fallbackDomain), message, error, context, false);
        } catch (initialError) {
          console.warn(initialError);

          try {
            return await sendErrorDetails(swFallbackErrorDomain, message, error, context, fallbackDomain);
          } catch (fallbackError) {
            console.warn(`sendFallbackError: ${fallbackError}`);
            return false;
          }
        }
      };
    },
    8066: (e, t) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Define various configuration properties
      t.chromeQuietPermissionVersion = undefined;
      t.swParamSuffix = undefined;
      t.swFallbackErrorDomain = undefined;
      t.swDefaultBanner = undefined;
      t.swFallbackZone = undefined;
      t.swSettingsKey = undefined;
      t.swRunCmdCache = undefined;
      t.swMetricsDb = undefined;
      t.swDatabase = undefined;
      t.antiAdBlockLogger = undefined;
      t.defaultBannerStaticDomain = undefined;
      t.defaultBannerDomain = undefined;
      t.swGidratorDomain = undefined;
      t.swPingDomain = undefined;
      t.swDomain = undefined;
      t.swVersion = undefined;

      // Set configuration values
      t.swVersion = '3.1.523';
      t.swDomain = 'https://jouteetu.net';
      t.swPingDomain = 'https://ddtvskish.com';
      t.swGidratorDomain = 'https://my.rtmark.net';
      t.defaultBannerDomain = 'https://duleonon.com';
      t.defaultBannerStaticDomain = 'https://littlecdn.com';
      t.antiAdBlockLogger = 'https://voonogoa.net';

      t.swDatabase = {
        name: 'swDatabase',
        version: 1,
        trackStore: 'trackStore',
      };

      t.swMetricsDb = {
        name: 'swMetrics',
        version: 1,
        trackStore: 'metricStore',
      };

      t.swRunCmdCache = 'runCmdCache';
      t.swSettingsKey = 'swSettings';
      t.swFallbackZone = 3660999;

      // Define default banner options
      const defaultBannerOptions = {
        silent: false,
        requireInteraction: true,
        body: 'We found 1 offer that might interest you',
        icon: `${t.defaultBannerStaticDomain}/contents/s/a7/7e/0e/cd3532bd32a6204b055dd7dd36/01027922412470.png`,
        data: { url: `${t.defaultBannerDomain}/4/${t.swFallbackZone}` },
      };

      t.swDefaultBanner = {
        code: 'show',
        title: 'Personal Offer for You.',
        trace_id: '',
        is_empty: true,
        options: defaultBannerOptions,
      };

      t.swFallbackErrorDomain = 'https://amunfezanttor.com';
      t.swParamSuffix = 'AxXB324Fe';
      t.chromeQuietPermissionVersion = 77;
    },
    7224: (e, t) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the getBrowserStat function as undefined
      t.getBrowserStat = undefined;

      // Define the getBrowserStat function
      t.getBrowserStat = async function() {
        let temp;
        const stats = {};

        // Check if the device is a mobile device
        try {
          stats['IM'] = /iphone|ipad|android|windows phone/i.test(navigator.userAgent) ? 1 : 0;
        } catch (e) {
        }

        // Screen width
        try {
          stats['SW'] = window.screen.width;
        } catch (e) {
        }

        // Screen height
        try {
          stats['SH'] = window.screen.height;
        } catch (e) {
        }

        // Available screen height
        try {
          stats['SAH'] = window.screen.availHeight;
        } catch (e) {
        }

        // Screen X position
        try {
          stats['WX'] = window.screenX;
        } catch (e) {
        }

        // Screen Y position
        try {
          stats['WY'] = window.screenY;
        } catch (e) {
        }

        // Outer width
        try {
          stats['WW'] = window.outerWidth;
        } catch (e) {
        }

        // Outer height
        try {
          stats['WH'] = window.outerHeight;
        } catch (e) {
        }

        // Inner width
        try {
          stats['WIW'] = window.innerWidth;
        } catch (e) {
        }

        // Inner height
        try {
          stats['WIH'] = window.innerHeight;
        } catch (e) {
        }

        // Client width
        try {
          stats['CW'] = document.documentElement.clientWidth;
        } catch (e) {
        }

        // Number of frames
        try {
          stats['WFC'] = (temp = window.top) == null ? undefined : temp.frames.length;
        } catch (e) {
        }

        // Document location
        try {
          stats['PL'] = typeof document !== 'undefined' ? document.location.href : '';
        } catch (e) {
        }

        // Document referrer
        try {
          stats['DRF'] = typeof document !== 'undefined' ? document.referrer : '';
        } catch (e) {
        }

        // Navigator plugins
        try {
          stats['NP'] = navigator.plugins instanceof PluginArray && navigator.plugins.length ? 1 : 0;
        } catch (e) {
        }

        // PhantomJS detection
        try {
          stats['PT'] = typeof window.callPhantom !== 'undefined' || typeof window._phantom !== 'undefined' ? 1 : 0;
        } catch (e) {
        }

        // Navigator sendBeacon support
        try {
          stats['NB'] = typeof navigator.sendBeacon === 'function' ? 1 : 0;
        } catch (e) {
        }

        // Navigator geolocation support
        try {
          stats['NG'] = typeof navigator.geolocation !== 'undefined' ? 1 : 0;
        } catch (e) {
        }

        // Navigator webdriver detection
        try {
          stats['NW'] = typeof navigator.webdriver !== 'undefined' && navigator.webdriver ? 1 : 0;
        } catch (e) {
        }

        // Check if in an iframe
        try {
          stats['IX'] = window.self !== window.top;
        } catch (e) {
        }

        // Navigator language
        try {
          stats['NAVLNG'] = window.navigator.language;
        } catch (e) {
        }

        // Touch support
        try {
          stats['IST'] = document.documentElement != null && 'ontouchstart' in window;
        } catch (e) {
        }

        // WebGL information
        try {
          stats['WGL'] = (() => {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!context || !(context instanceof WebGLRenderingContext)) return '';
            const debugInfo = context.getExtension('WEBGL_debug_renderer_info');
            return debugInfo ? String(context.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)) : '';
          })();
        } catch (e) {
        }

        // Headless browser detection
        try {
          stats['HIL'] = (() => {
            const ua = navigator.userAgent || '';
            const isEmptyUa = !ua;
            const isHeadlessChrome = /HeadlessChrome/i.test(ua);
            const isChrome = /chrome|chromium/i.test(ua);
            const isOpera = /opera/i.test(ua);
            const isMobile = /iphone|ipad|android|windows phone/i.test(navigator.userAgent);
            const isWebdriver = !!navigator.webdriver;
            const isPhantom = !!(window.callPhantom || window._phantom || (() => {
              try {
                null[0]();
              } catch (e) {
                return e && e.stack && e.stack.includes('phantomjs');
              }
              return false;
            })());
            const isNonChrome = !window.chrome;
            const isNoPlugins = (() => {
              try {
                return !(navigator.plugins instanceof PluginArray && navigator.plugins.length) || !Array.from(navigator.plugins).filter(e => e instanceof Plugin && e.name).length;
              } catch (e) {
                return false;
              }
            })();
            return isEmptyUa || isHeadlessChrome || isWebdriver || isPhantom || (isChrome || isOpera) && isNonChrome && !isMobile || isChrome && isNoPlugins && !isMobile ? 1 : 2;
          })();
        } catch (e) {
        }

        // Async/Await support
        try {
          stats['AA'] = (() => {
            try {
              const randomString = Math.random().toString(36).slice(2);
              window[randomString] = false;
              const script = document.createElement('script');
              script.innerHTML = `try{eval("(() => { const a = async function name () {}; window['${randomString}'] = true; })()")}catch(e){}`;
              document.head.appendChild(script);
              const result = window[randomString];
              delete window[randomString];
              return result;
            } catch (e) {
              return false;
            }
          })();
        } catch (e) {
        }

        // Battery status
        try {
          if (navigator.getBattery) {
            const battery = await navigator.getBattery();
            if (battery) {
              stats['BAC'] = battery.charging;
              if (battery.chargingTime || battery.chargingTime === 0) stats['BACT'] = battery.chargingTime;
              if (battery.level || battery.level === 0) stats['BAL'] = battery.level;
              if (battery.dischargingTime || battery.dischargingTime === 0) stats['BADT'] = battery.dischargingTime;
            }
          }
        } catch (e) {
        }

        return stats;
      };
    },
    7767: (e, t, r) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      // Initialize the qualityStore function as undefined
      t.qualityStore = undefined;

      const trackDb = r(6344);
      const qualityFormKey = 'qualityForm';

      // Define the qualityStore object with get and save methods
      t.qualityStore = {
        // Method to get the quality form data from the trackDb
        get: async function() {
          try {
            return await trackDb.trackDb.get(qualityFormKey);
          } catch (e) {
            // Handle any errors (optional)
          }
          return null;
        },

        // Method to save the quality form data to the trackDb
        save: async function(data) {
          try {
            await trackDb.trackDb.set(qualityFormKey, data);
          } catch (e) {
            // Handle any errors (optional)
          }
        },
      };
    },
    1517: (e, t, r) => {
      // Define the module exports
      Object.defineProperty(t, '__esModule', { value: true });

      t.isAlreadySubscribed = t.registerServiceWorker = t.fetchZoneSettings = t.getAlreadyRegistered = t.waitBeforeProceed = t.getZoneSettingsUrl = t.initMicroTag = t.runMicroTag = t.sendRequest = t.isAlreadyRegistered = t.logAlreadyRegistered = undefined;

      const n = r(3882);
      const o = r(9321);
      const i = r(9618);
      const a = r(8066);
      const s = r(3010);
      const c = r(8366);
      const d = r(9178);
      const u = r(3833);
      const l = r(9300);
      const g = r(9814);
      const p = r(6837);
      const m = r(7767);
      const _ = r(3463);
      const y = r(351);
      const f = r(9120);
      const v = r(6344);
      const w = r(3578);
      const h = r(8183);
      const b = r(6301);
      const k = r(3544);
      const S = r(7224);
      const D = ['var', 'var_3', 'var_4', 'ymid', 'ab2', 'ab2_ttl', 'uhd', 'zoneId'];

      // Helper function to check if any item in the array matches the condition
      async function E(e, t) {
        return e.filter(t).length > 0;
      }

      // Helper function to build service worker URL with query parameters
      function P(e) {
        const t = D.reduce((t, r) => (t[r] = encodeURIComponent(e[r] || ''), t), {});
        const queryString = Object.entries(t).filter(([, e]) => Boolean(e)).map(([e, t]) => `${e}=${t}`).join('&');
        return `${e.swName || '/sw-check-permissions.js'}${queryString ? `?${queryString}` : ''}`;
      }

      // Helper function to send a request using navigator.sendBeacon or fetch
      function O(e) {
        navigator.sendBeacon ? navigator.sendBeacon(e) : fetch(e);
      }

      // Helper function to get the zone settings URL with client hints
      async function R(e, t, r) {
        const n = a.swPingDomain.startsWith('https://') ? a.swPingDomain.slice(8) : a.swPingDomain;
        const o = (e.cdn ? e.domain : e.domain || r.host) || n;
        const i = /iPhone|iPad|iPod/.test(navigator.userAgent) || /android/i.test(navigator.userAgent);
        const s = /^localhost:\d+$/.test(o) ? 'http' : 'https';
        const c = {
          pub: 0 | (e.pub || 0),
          zone_id: e.zoneId,
          is_mobile: String(i),
          domain: location.hostname,
          var: encodeURIComponent(e.var || ''),
          ymid: encodeURIComponent(e.ymid || ''),
          var_3: encodeURIComponent(e.var_3 || ''),
          var_4: encodeURIComponent(e.var_4 || ''),
          dsig: e.dsig || '',
          tg: 1,
          sw: a.swVersion,
          trace_id: t,
        };
        if (e.ab2) c.experiment = e.ab2;
        const queryString = Object.keys(c).reduce((e, t) => `${e}&${t}=${c[t]}`, `${s}://${o}/zone?`);
        const [u, l] = await (0, w.concatClientHints)([`${queryString}&action=prerequest`, `${queryString}&action=settings`]);
        return {
          preRequestUrl: u,
          settingsUrl: l,
        };
      }

      // Helper function to wait before proceeding based on user activity
      async function B(e, t) {
        if (typeof e.notificationsDelayHttps === 'number') await (0, s.delay)(e.notificationsDelayHttps);
        if (t.isFF || t.isSafariDesktop || e.wua) await (0, c.waitUserActivity)();
      }

      // Helper function to check if the service worker is already registered
      async function x(e) {
        try {
          return E([...await e.getRegistrations()], ({ scope: e }) => e === `https://${location.host}/sw-check-permissions/` || e === `https://${location.host}/`);
        } catch (e) {
          const t = e;
          t.error_level = 'micro';
          if (t.message && u.SW_BROWSER_ERROR_REG.test(t.message)) throw t;
          return (0, d.sendError)('micro_tag_sw_get_registrations_error:', t, {}), false;
        }
      }

      // Helper function to fetch zone settings
      function I(e) {
        const t = performance.now();
        return h.eventLogger.send({ event_type: 'before_fetch_zone_settings' }, a.swFallbackErrorDomain), fetch(e).then(e => e.json()).then(e => {
          if (e.injections) {
            try {
              (0, l.inject)(e.injections);
            } catch (e) {
            }
          }
          h.eventLogger.send({
            event_type: 'after_fetch_zone_settings',
            duration: performance.now() - t | 0,
          }, a.swFallbackErrorDomain);
          return e;
        }).catch(e => {
          e.error_level = 'micro';
          (0, d.sendError)('micro_tag_fetch_zone_settings_error:', e, {});
          h.eventLogger.send({
            event_type: 'after_fetch_zone_settings',
            duration: performance.now() - t | 0,
          }, a.swFallbackErrorDomain);
          return null;
        });
      }

      // Log already registered service workers
      t.logAlreadyRegistered = async function(e, t) {
        if (e.length === 0) return;
        const r = new Error();
        r.error_level = 'micro';
        const n = {
          installer_type: 'micro',
          user_key: {
            user: t ? t.user : undefined,
            pub: t ? t.pub : undefined,
          },
        };
        try {
          const o = [];
          const i = [];
          for (const t of e) {
            const e = t.active || t.waiting;
            if (e && e.scriptURL) o.push(e.scriptURL);
            const r = await t.pushManager.getSubscription();
            if (r) {
              const e = r.toJSON();
              if (e.keys && e.keys.auth) i.push(e.keys.auth);
            }
          }
          r.message = `reg-ctx-auth - ${t ? t.auth : undefined}, pushSubAuthKeys - ${JSON.stringify(i)}, reg-ctx-z - ${t ? t.zoneId : undefined}, scriptURLs - ${o}`;
          (0, d.sendError)('already_registered_sw_log:', r, n);
        } catch (e) {
          (0, d.sendError)('already_registered_sw_error:', r, n);
        }
      };

      t.isAlreadyRegistered = E;
      t.sendRequest = O;

      // Run the micro tag script
      t.runMicroTag = async function(e, t, r, n) {
        const o = navigator.serviceWorker;
        h.eventLogger.send({ event_type: 'before_ask_gidrator' }, a.swFallbackErrorDomain);
        const i = performance.now();
        const s = (0, g.askGidrator)({
          gidratorDomain: a.swGidratorDomain,
          checkDuplicate: true,
          pub: 0 | (e.pub || 0),
          zoneId: e.zoneId,
          timeout: 5000,
          var_id: e.var,
          ymid: e.ymid,
          var_3: e.var_3,
          pusherDomainOAID: e.oaid,
          context: 'micro',
        });
        s.then(({ skipInstall: e }) => {
          h.eventLogger.send({
            event_type: 'after_ask_gidrator',
            duration: performance.now() - i | 0,
          }, a.swFallbackErrorDomain);
          if (e) p.gidCookie.skipByGidForDay();
        });
        try {
          await B(e, t);
        } catch (e) {
        }
        const c = function() {
          h.eventLogger.send({ event_type: 'request_permission' }, a.swFallbackErrorDomain);
          const e = performance.now();
          return Notification.requestPermission().then(t => {
            h.eventLogger.send({
              event_type: `request_permission_resolve_${t}`,
              duration: performance.now() - e | 0,
            }, a.swFallbackErrorDomain);
            return t;
          });
        }();
        try {
          await m.qualityStore.save(await (0, S.getBrowserStat)());
        } catch (e) {
        }
        try {
          await async function(e) {
            await (0, v.trackDb)().set('registration_user_context', e);
          }({ trace_id: n });
        } catch (e) {
          const t = e;
          t.error_level = 'micro';
          (0, d.sendError)('micro_tag_init_reg_context:', t, {});
        }
        let u = false;
        try {
          u = await x(o);
        } catch (e) {
          if (typeof e !== 'boolean') throw e;
        }
        I(r);
        return {
          alreadyRegistered: u,
          alreadySubscribedPromise: s,
          permissionPromise: c,
        };
      };

      // Initialize the micro tag
      t.initMicroTag = async function() {
        const t = document.currentScript;
        const r = t.src || t.dataset.src;
        const s = new URL(r || '');
        const c = (0, n.getOptionsFromUrl)(s);
        const u = t.onload || (() => {
        });
        const l = (0, f.uuid4)();
        const g = P(c);
        const p = (0, o.browsersDetection)(navigator.userAgent);
        if (!c.noel) {
          h.eventLogger.setContext(c.domain || a.swDomain, (0, k.buildInstallEventParams)(c, l, 'micro'));
          if (c.rpo) (0, b.runPerformanceObserver)({
            context: 'micro',
            traceId: l,
          });
        }
        h.eventLogger.send({ event_type: 'init_micro_tag' }, a.swFallbackErrorDomain);

        // Load Safari specific script
        (function(e, t) {
          if (!e.isSafariDesktop) return;
          const r = document.createElement('script');
          r.src = `${t}/3bT/27mJf/micro.safari.tag.min.js`;
          document.head.appendChild(r);
        })(p, s.origin);

        // Prefetch the service worker
        (function(e) {
          const t = document.createElement('link');
          t.setAttribute('rel', 'prefetch');
          t.setAttribute('href', e);
          document.head.appendChild(t);
        })(g);

        t.onload = null;

        const m = {
          onBeforePermissionPrompt: function() {
            u('onBeforePermissionPrompt');
          },
          onPermissionDefault: function() {
            u('onPermissionDefault');
          },
          onPermissionAllowed: function() {
            u('onPermissionAllowed');
          },
          onPermissionDenied: function() {
            u('onPermissionDenied');
          },
          onAlreadySubscribed: function() {
            u('onAlreadySubscribed');
          },
          onNotificationUnsupported: function() {
            u('onNotificationUnsupported');
          },
        };

        (0, i.broadcastInfo)('pusher-microtag', a.swVersion, c.zoneId, t);

        const {
          preRequestUrl: v,
          settingsUrl: w,
        } = await R(c, l, s);

        try {
          h.eventLogger.send({ event_type: 'before_prerequest' }, a.swFallbackErrorDomain);
          O(`${v}&drf=${document.referrer}`);
          h.eventLogger.send({ event_type: 'after_prerequest' }, a.swFallbackErrorDomain);
        } catch (e) {
          const t = e;
          t.error_level = 'micro';
          (0, d.sendError)('micro_tag_cant_send_prerequest_error:', t, {});
        }

        const S = (0, y.isPushSupported)();
        return {
          isPushSupported: S,
          isInstallAvailable: t && !(0, _.isGoogleLighthouse)(),
          alreadyGranted: S && 'granted' === (null === (e = null === window || undefined === window ? undefined : window.Notification) || undefined === e ? undefined : e.permission),
          urlOptions: c,
          browser: p,
          settingsUrl: w,
          sdk: m,
          traceID: l,
        };
      };

      t.getZoneSettingsUrl = R;
      t.waitBeforeProceed = B;
      t.getAlreadyRegistered = x;
      t.fetchZoneSettings = I;

      // Register the service worker
      t.registerServiceWorker = async function(e) {
        const t = P(e);
        try {
          return await navigator.serviceWorker.register(t);
        } catch (e) {
          const t = e;
          t.error_level = 'micro';
          (0, d.sendError)('micro_tag_cant_register_sw:', t, {});
        }
      };

      // Check if the user is already subscribed
      t.isAlreadySubscribed = async function(e) {
        let t = p.gidCookie.isSkippedByGidForDay();
        try {
          t = t || (await e).skipInstall;
        } catch (e) {
        }
        return t;
      };
    },
  };

  var t = {};

  function getModule(n) {
    var o = t[n];
    if (undefined !== o) {
      return o['exports'];
    }
    var i = t[n] = { 'exports': {} };
    return e[n]['call'](i['exports'], i, i['exports'], getModule), i['exports'];
  }

  (async () => {
    const appLock = getModule(3833);
    const subscriptionUtils = getModule(158);
    const errorLogger = getModule(9178);
    const microTag = getModule(1517);
    const eventLogger = getModule(8183);
    const config = getModule(8066);
    const trackDb = getModule(6344);

    let permissionStatus;

    const {
      isInstallAvailable,
      urlOptions,
      sdk,
      browser,
      isPushSupported,
      settingsUrl,
      traceID,
    } = await microTag.initMicroTag();

    window.addEventListener('beforeunload', () => {
      if (!permissionStatus) {
        eventLogger.eventLogger.send({ event_type: 'left_page' + (isPushSupported ? '_empty_permission' : '_push_unsupported') }, config.swFallbackErrorDomain);
      }
    });

    if (!isInstallAvailable) {
      const error = new Error();
      error.error_level = 'micro';
      return errorLogger.sendError('micro_tag_install_unavailable:', error, {});
    }

    if (!isPushSupported) {
      urlOptions.nouns || sdk.onNotificationUnsupported();
      const error = new Error();
      error.error_level = 'micro';
      return errorLogger.sendError('micro_tag_push_unsupported:', error, {});
    }

    try {
      sdk.onBeforePermissionPrompt();

      const {
        alreadyRegistered,
        alreadySubscribedPromise,
        permissionPromise,
      } = await microTag.runMicroTag(urlOptions, browser, settingsUrl, traceID);

      permissionStatus = await permissionPromise;

      const isSubscribed = await subscriptionUtils.isMyCurrentSubscription('');
      const hasPermissionCheck = await subscriptionUtils.isMyCurrentSubscription('/sw-check-permissions/');
      const eventType = 'granted_sw_is_my_current_subscription_control';

      if (permissionStatus === 'granted') {
        eventLogger.eventLogger.send({ event_type: 'granted_app_is_locked_checking' }, config.swFallbackErrorDomain);

        if (await appLock.isLocked()) {
          console.log('appLock');
          eventLogger.eventLogger.send({ event_type: 'granted_app_is_locked_true' }, config.swFallbackErrorDomain);
          return sdk.onAlreadySubscribed();
        }

        if (isSubscribed) {
          eventLogger.eventLogger.send({ event_type: eventType }, config.swFallbackErrorDomain);
          return sdk.onAlreadySubscribed();
        }

        if (hasPermissionCheck) {
          eventLogger.eventLogger.send({ event_type: `${eventType}_our` }, config.swFallbackErrorDomain);
          return sdk.onAlreadySubscribed();
        }

        if (alreadyRegistered) {
          eventLogger.eventLogger.send({ event_type: `${eventType}_unknown` }, config.swFallbackErrorDomain);
          try {
            const serviceWorker = navigator.serviceWorker;
            const registrations = await serviceWorker.getRegistrations();
            const registrationContext = await trackDb.trackDb.get('registration-context');
            await microTag.logAlreadyRegistered(registrations, registrationContext);
          } catch (error) {
            errorLogger.sendError('cant_log_current_subscription:', error, {});
          }
        }

        eventLogger.eventLogger.send({ event_type: 'before_register_service_worker' }, config.swFallbackErrorDomain);

        const registration = await appLock.runReleaseOnFail(() => microTag.registerServiceWorker(urlOptions));

        eventLogger.eventLogger.send({ event_type: 'after_register_service_worker' }, config.swFallbackErrorDomain);

        if (registration && browser.isSafariDesktop && window.zfgsafari) {
          try {
            await window.zfgsafari(registration, urlOptions.pub);
          } catch (error) {
            error.error_level = 'micro';
            errorLogger.sendError('micro_tag_safari_cant_subscribe_error:', error, {});
            return sdk.onNotificationUnsupported();
          }
        }
      } else if (alreadyRegistered) {
        eventLogger.eventLogger.send({ event_type: `not_granted_sw_is_already_registered_${permissionStatus}` }, config.swFallbackErrorDomain);
      }

      if (await microTag.isAlreadySubscribed(alreadySubscribedPromise)) {
        return sdk.onAlreadySubscribed();
      }

      switch (permissionStatus) {
        case 'default':
          return sdk.onPermissionDefault();
        case 'granted':
          return sdk.onPermissionAllowed();
        case 'denied':
          return sdk.onPermissionDenied();
      }
    } catch (error) {
      if (error === appLock.LOCK_FAILED) {
        return sdk.onAlreadySubscribed();
      }

      error.error_level = 'micro';
      errorLogger.sendError('micro_tag_run_error:', error, {});
      sdk.onNotificationUnsupported();
    }
  })();

})();
